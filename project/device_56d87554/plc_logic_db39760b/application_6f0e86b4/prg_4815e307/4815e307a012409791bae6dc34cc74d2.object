{"payload":{"meta":{"Graph":{"@Type":"81297157","@Value":{"Guid":"(Guid)4815e307-a012-4097-91ba-e6dc34cc74d2","ParentGuid":"(Guid)6f0e86b4-18a4-4e3d-9377-448004deeefc","Name":"(string)PRG","Properties":{"@Type":"2c41fa04:IDictionary","@Value":{}},"TypeGuid":"(Guid)6f9dac99-8de1-4efc-8465-68ac443b7d08","EmbeddedTypeGuids":{"@Type":"[Guid]","@Value":["(Guid)a9ed5b7e-75c5-4651-af16-d2c27e98cb94","(Guid)3b83b776-fb25-43b8-99f2-3c507c9143fc"]}}},"TypeInfos":{"2c41fa04":"{2c41fa04-1834-41c1-816e-303c7aa2c05b}","81297157":"{81297157-7ec9-45ce-845e-84cab2b88ade}","Guid":"System.Guid","string":"System.String"}},"object":{"Graph":{"@Type":"6f9dac99","@Value":{"SpecialFunc":{"@Type":"0db3d7bb:Enum","@Value":"None"},"Implementation":{"@Type":"3b83b776","@Value":{"TextDocument":{"@Type":"f3878285","@Value":{"TextBlobForSerialisation":"(string)(* Timer TON for handling reconnection delay *)\ntReconnectTimer(IN := xReconnect, PT := tReconnectTime);\n\n(* Automatic reconnection logic *)\nIF (NOT xConnectedToBroker AND NOT tReconnectTimer.Q) THEN\n    xReconnect := TRUE;\nELSIF tReconnectTimer.Q THEN\n    xReconnect := FALSE; \n    xStart := TRUE; (* Retry connection *)\nEND_IF\n\n// (* Reset error if present *)\nIF xError THEN\n    xStart := FALSE;\n    xReconnect := TRUE;\n    xError := FALSE; (* Clear error flag *)\nEND_IF;\n\n// MQTT client\nmqttClient(\n\txEnable:= xStart, \n\txDone=> , \n\txBusy=> , \n\txError=> xError, \n\tuiPort:= uiPort, \n\txUseTLS:= , \n\tuiKeepAlive:= , \n\tpbWillMessage:= ADR(sWillMessage), \n\tuiWillMessageSize:= DINT_TO_UINT(Stu.StrLenA(ADR(sWillMessage))), \n\txWillRetain:= , \n\teWillQoS:= , \n\txCleanSession:= , \n\twsUsername:= , \n\twsPassword:= , \n\twsWillTopic:= , \n\tsClientId:= , \n\ttPingInterval:= , \n\thCert:= , \n\titfTLSContext:= , \n\titfAsyncProperty:= , \n\tudiTimeOut:= , \n\teCommunicationMode:= eCommunicationMode, \n\tsWebSocketUrl:= sHostname, \n\teMQTTVersion:= eMQTTVersion, \n\tmQTTConnectProperties:= mQTTConnectProperties, \n\tmQTTWillProperties:= mQTTWillProperties, \n\tsHostname:= sHostname, \n\teMQTTError=> , \n\txConnectedToBroker=> xConnectedToBroker, \n\teReaonCode=> , \n\tmQTTConnackProperties=> );\n\t\n\t// subscribe to a topic subscriber 1\n\tmqttSubscriber(\n\t\txEnable:= , \n\t\txDone=> , \n\t\txBusy=> , \n\t\txError=> , \n\t\teSubscribeQoS:= , \n\t\tpbPayload:= ADR(sSubscribeMessage), \n\t\tudiMaxPayloadSize:= SIZEOF(sSubscribeMessage), \n\t\teFilterMode:= , \n\t\tmQTTSubscribeProperties:= mQTTSubscribeProperties, \n\t\tudiTimeout:= , \n\t\tmqttClient:= mqttClient, \n\t\twsTopicFilter:= wsSubcribeTopicFilter, \n\t\teMQTTError=> , \n\t\txReceived=> , \n\t\tudiPayloadSize=> , \n\t\txSubscribeActive=> , \n\t\twsLastTopic=> , \n\t\tmQTTPublishProperties=> );\n\t\n\tTerminateString(psIn:= ADR(sSubscribeMessage), udiLength:= mqttSubscriber.udiMaxPayloadSize );\n\n// subscribe to a topic subscriber 1\nmqttSubscriber2(\n\txEnable:= , \n\txDone=> , \n\txBusy=> , \n\txError=> , \n\teSubscribeQoS:= , \n\tpbPayload:= ADR(sSubscribeMessage2), \n\tudiMaxPayloadSize:= SIZEOF(sSubscribeMessage2), \n\teFilterMode:= , \n\tmQTTSubscribeProperties:= mQTTSubscribeProperties, \n\tudiTimeout:= , \n\tmqttClient:= mqttClient, \n\twsTopicFilter:= wsSubcribeTopicFilter2, \n\teMQTTError=> , \n\txReceived=> , \n\tudiPayloadSize=> , \n\txSubscribeActive=> , \n\twsLastTopic=> , \n\tmQTTPublishProperties=> );\n\t\n\tTerminateString(psIn:= ADR(sSubscribeMessage2), udiLength:= mqttSubscriber2.udiMaxPayloadSize );\n\n// Publish a message 1\n\n// Start timer with a 5-second interval\nfbTimerPubblish(IN := TRUE, PT := tIntervalPublish);\ntIntervalPublish := tTimePublish;\n\n\n// Trigger JSON creation on timer completion\nIF fbTimerPubblish.Q THEN\n    xPublish := TRUE;\n    fbTimerPubblish(IN := FALSE); // Restart timer\n    fbTimerPubblish(IN := TRUE);\nEND_IF;\n\n\nsPublishMessage := OEE_PRG.wsJsonData;\nudiLength:=Stu.StrLenW(ADR(sPublishMessage))*2;\nwsPublishTopic := TO_WSTRING(OEE_PRG.topic1);\n\nmqttPublisher(\n\txExecute:= xPublish AND xConnectedToBroker, \n\tudiTimeOut:= 10000000, \n\txDone=> , \n\txBusy=> , \n\txError=> , \n\teQoS:= , \n\txReDelivery:= , \n\txRetain:= , \n\tpbPayload:= ADR(sPublishMessage), \n\tudiPayloadSize:= udiLength, \n\tmQTTPublishProperties:= mqTTPublishProperties, \n\tmqttClient:= mqttClient, \n\twsTopicName:= wsPublishTopic, \n\teMQTTError=> );\n\t\nIF mqttPublisher.xDone THEN\n\txPublish := FALSE;\nEND_IF\n\t\nrsPub1Done(\n\tSET:= mqttPublisher.xDone,\n\tRESET1:= mqttPublisher.xBusy,\n);\n\nrsPub1Error(\n\tSET:= mqttPublisher.xError,\n\tRESET1:= mqttPublisher.xBusy  );\n\t\n// Publish a message 2\nmqttPublisher2(\n    xExecute:= ,\n    udiTimeOut:= 10000000,\n    xDone=> ,\n    xBusy=> ,\n    xError=> ,\n    eQoS:= ,\n    xReDelivery:= ,\n    xRetain:= ,\n    pbPayload:= ADR(sPublishMessage2),\n    udiPayloadSize:= DINT_TO_UDINT(Stu.StrLenA(ADR(sPublishMessage2))),\n    mQTTPublishProperties:= mqTTPublishProperties,\n    mqttClient:= mqttClient,\n    wsTopicName:= wsPublishTopic2,\n    eMQTTError=> );\n\t\nrsPub2Done(\n    SET:= mqttPublisher2.xDone,\n    RESET1:= mqttPublisher2.xBusy\n);\n\nrsPub2Error(\n    SET:= mqttPublisher2.xError,\n    RESET1:= mqttPublisher2.xBusy\n);\n\n\t\n\t","LineInfoPersistence":"(string)4815e307-a012-4097-91ba-e6dc34cc74d2_Impl_LineIds"}}}},"Interface":{"@Type":"a9ed5b7e","@Value":{"TextDocument":{"@Type":"f3878285","@Value":{"TextBlobForSerialisation":"(string)PROGRAM PRG\nVAR\n\n    xStart: BOOL := TRUE;                  (* Flag to initiate connection *)\n    xReconnect: BOOL := FALSE;             (* Flag to trigger reconnection *)\n    tReconnectTime: TIME := T#5S;          (* Delay before retrying connection *)\n    tReconnectTimer: TON;                  (* Timer for reconnection delay *)\n\txError: BOOL;                          (* Error flag *)\n\n\txConnectedToBroker: BOOL;              (* Connection status *)\n\n\n\tmqttClient : MQTT.MQTTClient; // Function block to establish a connection to a MQTT broker\n\tmqttPublisher : MQTT.MQTTPublish; // Function block to publish MQTT messages\n\tmqttPublisher2 : MQTT.MQTTPublish; // Function block to publish MQTT messages\n\tmqttSubscriber : MQTT.MQTTSubscribe; // Function block to subscribe MQTT topics\n\tmqttSubscriber2 : MQTT.MQTTSubscribe; // Function block to subscribe MQTT topics\n\tsHostname : STRING(255) := 'localhost'; // Hostname or ip address or URL (for WebSockets: ws:// or wss://)\n\tuiPort : UINT := 1883; // Port of the MQTT broker\n\twsPublishTopic : WSTRING(1024) := \"\"; // Topic to publish a message\n\twsPublishTopic2 : WSTRING(1024) := \"\"; // Topic to publish a message\n\twsSubcribeTopicFilter : WSTRING(1024) := \"\"; // Topic filter to subcribe a topic\n\twsSubcribeTopicFilter2 : WSTRING(1024) := \"\"; // Topic filter to subcribe a topic\n\tsWillMessage : STRING(1024); // The last will message\n\tsPublishMessage : WSTRING(1024); // The messsage to publish\n\tsPublishMessage2 : STRING(1024) := ''; // The messsage to publish\n\tsSubscribeMessage : STRING(4096); // Message buffer with the retrieved message  \n\tsSubscribeMessage2 : STRING(4096); // Message buffer with the retrieved message  \n\trsPub1Error: RS; // Helper to publisher state\n\trsPub1Done: RS; // Helper to publisher state\n\trsPub2Error: RS; // Helper to publisher state\n\trsPub2Done: RS; // Helper to publisher state\n\teCommunicationMode : MQTT.COMMUNICATION_MODE := MQTT.COMMUNICATION_MODE.TCP; // Communication mode: TCP/IP or WebSockets\n\teMQTTVersion : MQTT.MQTT_VERSION := MQTT.MQTT_VERSION.V3_1_1; // The MQTT protocol version\n\tudiLength : UDINT;\n\t// Example of connect properties (V5 only)\n\tmQTTConnectProperties : MQTT.MQTTConnectProperties := (\n\t\tudiSessionExpiryInterval := 10,\n\t\tudiMaximumPacketSize := MQTT.MQTTParam.g_udiMaxPacketSize,\n\t\tuserProperties := \n\t\t\t[\n\t\t\t\t(wsKey := \"key1\", wsValue := \"value1\"),\n\t\t\t\t(wsKey := \"key2\", wsValue := \"value2\"),\t\n\t\t\t\t(wsKey := \"key3\", wsValue := \"value3\")\n\t\t\t]\n\t);\n\t\n\t// Example of will properties (V5 only)\n\tmQTTWillProperties : MQTT.MQTTWillProperties := (\n\t\tbPayloadFormatIndicator := 1, // 1: UTF-8, 0: Binary\n\t\twsContentType := \"text/plain\",\n\t\tudiMessageExpiryInterval := 60,\n\t\tudiWillDelayInterval := 60,\n\t\tuserProperties := \n\t\t[\n\t\t\t(wsKey := \"key1\", wsValue := \"value1\"),\n\t\t \t(wsKey := \"key2\", wsValue := \"value2\"),\t\n\t\t\t(wsKey := \"key3\", wsValue := \"value3\")\n\t\t]);\n\t\n\t// Example of publish properties (V5 only)\n\tmqTTPublishProperties : MQTT.MQTTPublishProperties := (\n\t\tbPayloadFormatIndicator := 1, // 1: UTF-8, 0: Binary\n\t\twsContentType := \"text/plain\",\n\t\tudiMessageExpiryInterval := 60,\n\t\tuserProperties := \n\t\t[\n\t\t\t(wsKey := \"key1\", wsValue := \"value1\"),\n\t\t \t(wsKey := \"key2\", wsValue := \"value2\"),\t\n\t\t\t(wsKey := \"key3\", wsValue := \"value3\")\n\t\t]\n\t);\n\t\n\t// Example of subscribe properties (V5 only)\n\tmQTTSubscribeProperties : MQTT.MQTTSubscribeProperties := (\n\t\tudiSubscriptionIdentifier := 4343,\n\t\tuserProperties := \n\t\t[\n\t\t\t(wsKey := \"key1\", wsValue := \"value1\"),\n\t\t \t(wsKey := \"key2\", wsValue := \"value2\"),\t\n\t\t\t(wsKey := \"key3\", wsValue := \"value3\")\n\t\t],\n\t\txNoLocalOption := FALSE\n\t);\n\t\n\t/// If you want to use client certificates, you can configure the connection via the TLS context.\n\t//\n\t// Example (static):\n\t//\n\t// _sCommonName : STRING := 'COMMON_NAME_OF_CERTIFICATE'; // CN of the certificate (common name). \n\t// _sCipherList : NBS.CIPHER_LIST := STRUCT(psList := ADR('HIGH'), udiSize := 5); // Cipher string see https://www.openssl.org/docs/man1.1.1/man1/ciphers.html\n\t// _ciDefaultCertInfo : NBS.CERT_INFO := (psInfo := ADR(_sCommonName), udiSize := SIZEOF(_sCommonName)); // CN of the certificate (common name)\n\t\n\t// _tlsContext : NBS.TLSContext := (\tsUseCaseName := _sCommonName, // A certificate is stored in the certificate store with the use case name. You can choose any name. Here we use the common name.\n\t//\t\t\t\t\t\t\t\t\tePurpose := NBS.PURPOSE.CLIENT_SIDE, // For client certificates set this to NBS.PURPOSE.CLIENT_SIDE\n\t//\t\t\t\t\t\t\t\t\tsTLSVersion := '1.2', // The TLS version\n\t//\t\t\t\t\t\t\t\t\tsCipherList := _sCipherList, // Set the cipher list\n\t//\t\t\t\t\t\t\t\t\tsHostname := 'HOSTNAME_OF_THE_BROKER', // The hostname of the broker\n\t//\t\t\t\t\t\t\t\t\tudiVerificationMode := 2, // 2 => Active Peer verification\n\t//\t\t\t\t\t\t\t\t\tciCertInfo := _ciDefaultCertInfo, // Set the cert info\n\t//\t\t\t\t\t\t\t\t\titfCertVerifer := 0); // 0 => No Verifier \n\t// \n\t// mqttClient : MQTT.MQTTClient := (itfTLSCOntext := _tlsContext);\n    //\n\t// You can use the method TLSContext.SetInitialValue to set the context while runtime and set the context via the input itfTLSCOntext of the client FB.\n\tfbTimerPubblish: Ton;\n\ttIntervalPublish: TIME;\n\txPublish: BOOL;\n\ttTimePublish: TIME := t#60s;\nEND_VAR\n\n","LineInfoPersistence":"(string)4815e307-a012-4097-91ba-e6dc34cc74d2_Decl_LineIds"}}}},"UniqueIdGenerator":"(string)573","POULevel":{"@Type":"8e575c5b:Enum","@Value":"Standard"},"ChildObjectGuids":{"@Type":"ArrayList:IList","@Value":[]},"AddAttributeSubsequent":"(bool)False"}},"TypeInfos":{"0db3d7bb":"{0db3d7bb-cde0-4416-9a7b-ce49a0124323}","3b83b776":"{3b83b776-fb25-43b8-99f2-3c507c9143fc}","6f9dac99":"{6f9dac99-8de1-4efc-8465-68ac443b7d08}","8e575c5b":"{8e575c5b-1d37-49c6-941b-5c0ec7874787}","a9ed5b7e":"{a9ed5b7e-75c5-4651-af16-d2c27e98cb94}","ArrayList":"System.Collections.ArrayList","bool":"System.Boolean","f3878285":"{f3878285-8e4f-490b-bb1b-9acbb7eb04db}","string":"System.String"}}},"FormatVersion":"1.0"}